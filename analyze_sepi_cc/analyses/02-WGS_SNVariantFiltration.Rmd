---
title: "Whole Genome Single Nucleotide Variant Filtration for Sepi Resistance"
author: "Nicholas F. Brazeau"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  rmarkdown::html_document:
    highlight: textmate
    theme: lumen
    toc: true
    code_folding: hide
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F, fig.width = 10, fig.height = 7, results = 'hide')

#............
# imports
#..........
library(vcfR)
library(GenomicRanges)
library(tidyverse)
library(RColorBrewer)
library(grid)
library(DT)
remotes::install_github("IDEELResearch/vcfRmanip", ref = "bb2c1976adddffcde7d088252ea0f0e6a3c2ceb8")
library(vcfRmanip)
source("~/Documents/GitHub/Sepi_Res_CaseStudy/Ranalysis/R/00-basic_vcf_manipulations.R")


# VCF IMPORT
qcvcf <- vcfR::read.vcfR("~/Documents/MountPoints/mountedScratchLL/Projects/Sepi_Res_CaseStudy/variants/Sepi_Res_CaseStudy_HaploCaller_joint.ann.vcf", verbose = F)

```


# Goal 
**Overall**: To detect putative drug resistance mutation(s) in clinical isolates of _S. epidermidis_ from a patient with phenotypic resistance.   
**Immediate**: QC and Analysis of Segregating Sites and putative Drug-rx mutations.

## Background
Over their course of treatment, a patient developed multi-drug resistant _S. epidermidis_. We are attempting to identify putative drug resistance mutations in line with the phenotypic data. **The purpose of this script is to filter the QC-passed VCFS**. 

 Thus far, I have done the following: 

1. Aligned with `bwa-mem` with default parameters to fasta from [NCBI](https://www.ncbi.nlm.nih.gov/genome/155?genome_assembly_id=299299)
2. Deduplicated and mate-fixed PE reads (python modules)
3. Variant called with `gatk haplotype caller`
4. Performed basic QC 
4. Used the previously built variant annotation file from `snpEff` (*Staphylococcus_epidermidis_atcc_12228*)



Overall, this VCF contains `r nrow(qcvcf@gt)` variants across `r (ncol(qcvcf@gt)-1)` samples. These are variants relative to the reference sequence and do not represent segregating sites.

## Raw SNP & INDEL Sites
There are `r paste0(sum(is.biallelic(extract.indels(qcvcf, return.indels=F))), "/", nrow(extract.indels(qcvcf, return.indels=F)@gt))` SNPs that were identified by the `gatk` pipeline.    
There are `r paste0(sum(is.biallelic(extract.indels(qcvcf, return.indels=T))), "/", nrow(extract.indels(qcvcf, return.indels=T)@gt))` INDELs that were identified by the `gatk` pipeline.    
**Hereafter, I have subsetted to SNPs**. INDELs will be analyzed in a separate script with `smoove`. 

```{r}
snpvcf <- vcfR::extract.indels(qcvcf, return.indels = F)
```

# Variant Filtration

Plan for Variant Filtration: 

1. Mask repetitive regions
2. Mask SNV 10bp up- or downstream of an INDEL
3. Subset to Segregating Sites 


## Masking Repeat Regions
```{r}
# http://mummer.sourceforge.net/manual/#coords

ncmer <- readr::read_tsv("~/Documents/MountPoints/mountedScratchLL/Projects/Sepi_Res_CaseStudy/Sepi_Res_CaseStudy.coords",
                          skip = 3)  %>% 
  magrittr::set_colnames(c("s1", "e1", "s2", "e2", "len1", "len2", "identity", "tag"))

# remove identical regions
ncmer <- ncmer %>% 
  dplyr::filter(s1 != s2 & e1 != e2) 

# what is the distribution of identify and similarity
summary(ncmer$identity); sd(ncmer$identity)

ncmer <- ncmer %>% 
  dplyr::filter(identity > 90) 

# now collapse regions
repeatregions <- data.frame( start = unlist(ncmer[,c("s1", "s2")]) , end = unlist(ncmer[, c("e1", "e2")]) ) %>% 
  dplyr::mutate(start_orient = ifelse(start < end, start, end),
                end_orient = ifelse(end < start, start, end))  %>% 
  dplyr::select(c("start_orient", "end_orient")) %>% 
  dplyr::filter(!duplicated(.)) 

```


## Masking Structural Variant Regions
*First read in INDELs identifed by `smoove` 

```{r}

lmpy <- vcfR::read.vcfR(file = "~/Documents/GitHub/Sepidermidis_resistance_hosp/lumpy/bamrefs/sepi_clincases-smoove.genotyped.vcf.gz")


indels.lmpy.regions <- vcfR::getFIX(lmpy, getINFO = T) %>% 
  as.tibble(.) %>% 
  dplyr::select(c("CHROM", "POS", "ALT", "INFO")) %>% 
  dplyr::filter(ALT %in% c("<DEL>", "<DUP>", "<INV>")) %>% 
  dplyr::mutate(end = stringr::str_split_fixed(INFO, ";", n=14)[,3],
                end = gsub(pattern = "END=", "", x = end),
                end = as.numeric(end),
                start = as.numeric(POS),
                start_orient = ifelse(start < end, start, end),
                end_orient = ifelse(end < start, start, end))  %>% 
  dplyr::filter(!duplicated(.)) %>% 
  dplyr::mutate(diff = end_orient - start_orient) %>%  # catch duplication events that are due to circular chomosomes
  dplyr::filter(diff < 1e6) %>% 
  dplyr::select(c("start_orient", "end_orient")) 


# now for translocations
tranls.lmpy.regions <- vcfR::getFIX(lmpy, getINFO = T) %>% 
  as.tibble(.) %>% 
  dplyr::select(c("CHROM", "POS", "ALT", "INFO")) %>% 
  dplyr::filter(! ALT %in% c("<DEL>", "<DUP>", "<INV>")) %>% 
  dplyr::mutate(end = stringr::str_extract(ALT, "[0-9]+"),
                end = as.numeric(end),
                start = as.numeric(POS),
                start_orient = ifelse(start < end, start, end),
                end_orient = ifelse(end < start, start, end))  %>% 
  dplyr::select(c("start_orient", "end_orient")) %>% 
  dplyr::filter(!duplicated(.)) %>% 
  dplyr::mutate(diff = end_orient - start_orient) %>%  # catch duplication events that are due to circular chomosomes
  dplyr::filter(diff < 1e6) %>% 
  dplyr::select(c("start_orient", "end_orient")) 


```


### Combine Mask Regions
```{r}
 
bpbuffer <- 50

mskrgns <- dplyr::bind_rows(repeatregions, indels.lmpy.regions, tranls.lmpy.regions) %>% 
  dplyr::rename(start = start_orient,
                end = end_orient) %>% 
  dplyr::mutate(
    seqname = "Chromosome",
    geneid = 1:nrow(.),
    start = start - bpbuffer,
    end = end + bpbuffer 
  ) 


snpvcf.masked <- vcfRmanip::vcffilter_ChromPos(vcfRobject = snpvcf,
                                               chromposbed = mskrgns)


```


Given that a lot of the variation seems to be due to differences from the referent sequence, we will subset to segregating sites. In addition, we will subset to only  singletons, as these are serial samples from the same host (i.e. can think of them as nearly technical replicates). Plus, any mutation that occurs that confers resistance should be maintained in more than one sample. Call as a monoclonal -- will subset based on _GT_. 

## Filter SNPs based on GT
First we will look at this filtering based on the GT calls. Going to drop loci that have more than 3/8 samples missing. 
```{r}

snpvcf.masked.seg <- vcfRmanip::vcfR2segsites_gt(snpvcf.masked)


```

Overall, we have `r nrow(snpvcf.masked.seg@fix)` segregating sites that passes our quality filters. 


```{r}
# will write this vcf out for analysis

saveRDS(object = snpvcf.masked.seg, file = "~/Documents/GitHub/Sepidermidis_resistance_hosp/Ranalysis/data/Sepi_QC_variantfile.RDS")
saveRDS(object = repeatregions, file = "~/Documents/GitHub/Sepidermidis_resistance_hosp/Ranalysis/data/repeat_regions.RDS")


```
